Модуль 3
3.1
Цель: применить на практике начальные знания о пространстве имён и оператор global. Закрепить навыки из предыдущих модулей.

Задача "Счётчик вызовов":
Порой необходимо отслеживать, сколько раз вызывалась та или иная функция. К сожалению, в Python не предусмотрен подсчёт вызовов автоматически.
Давайте реализуем данную фишку самостоятельно!

Вам необходимо написать 3 функции:
1.	Функция count_calls подсчитывающая вызовы остальных функций.
2.	Функция string_info принимает аргумент - строку и возвращает кортеж из: длины этой строки, строку в верхнем регистре, строку в нижнем регистре.
3.	Функция is_contains принимает два аргумента: строку и список, и возвращает True, если строка находится в этом списке, False - если отсутствует. Регистром строки при проверке пренебречь: UrbaN ~ URBAN.
Пункты задачи:
1.	Создать переменную calls = 0 вне функций.
2.	Создать функцию count_calls и изменять в ней значение переменной calls. Эта функция должна вызываться в остальных двух функциях.
3.	Создать функцию string_info с параметром string и реализовать логику работы по описанию.
4.	Создать функцию is_contains с двумя параметрами string и list_to_search, реализовать логику работы по описанию.
5.	Вызвать соответствующие функции string_info и is_contains произвольное кол-во раз с произвольными данными.
6.	Вывести значение переменной calls на экран(в консоль).

Пример результата выполнения программы:
Пример выполняемого кода:
print(string_info('Capybara'))
print(string_info('Armageddon'))
print(is_contains('Urban', ['ban', 'BaNaN', 'urBAN'])) # Urban ~ urBAN
print(is_contains('cycle', ['recycling', 'cyclic'])) # No matches
print(calls)
Вывод на консоль:
(8, 'CAPYBARA', 'capybara')
(10, 'ARMAGEDDON', 'armageddon')
True
False
4
Примечания:
1.	Для использования глобальной переменной внутри функции используйте оператор global.
2.	Для функции is_contains лучше привести и искомую строку и все строки в списке в один регистр.

Успехов!


3.2  "Способы вызова функции"
Цель: закрепить знания о параметрах по умолчанию и именованных аргументах.

Задача "Рассылка писем":
Часто при разработке и работе с рассылками писем(e-mail) они отправляются от одного и того же пользователя(администрации или службы поддержки). Тем не менее должна быть возможность сменить его в редких случаях.
Попробуем реализовать функцию с подробной логикой.

Создайте функцию send_email, которая принимает 2 обычных аргумента: сообщение и получатель и 1 обязательно именованный аргумент со значением по умолчанию - отправитель.
Внутри функции реализовать следующую логику:
1.	Проверка на корректность e-mail отправителя и получателя.
2.	Проверка на отправку самому себе.
3.	Проверка на отправителя по умолчанию.
Пункты задачи:
1.	Создайте функцию send_email, которая принимает 2 обычных аргумента: message(сообщение), recipient(получатель) и 1 обязательно именованный аргумент со значением по умолчанию sender = "university.help@gmail.com".
2.	Если строки recipient и sender не содержит "@" или не оканчивается на ".com"/".ru"/".net", то вывести на экран(в консоль) строку: "Невозможно отправить письмо с адреса <sender> на адрес <recipient>".
3.	Если же sender и recipient совпадают, то вывести "Нельзя отправить письмо самому себе!"
4.	Если же отправитель по умолчанию - university.help@gmail.com, то вывести сообщение: "Письмо успешно отправлено с адреса <sender> на адрес <recipient>."
5.	В противном случае вывести сообщение: "НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса <sender> на адрес <recipient>."
6.	Здесь <sender> и <recipient> - значения хранящиеся в этих переменных.
7.	За один вызов функции выводится только одно из перечисленных уведомлений! Проверки перечислены по мере выполнения.

Пример результата выполнения программы:
Пример выполняемого кода (тесты):
send_email('Это сообщение для проверки связи', 'vasyok1337@gmail.com')
send_email('Вы видите это сообщение как лучший студент курса!', 'urban.fan@mail.ru', sender='urban.info@gmail.com')
send_email('Пожалуйста, исправьте задание', 'urban.student@mail.ru', sender='urban.teacher@mail.uk')
send_email('Напоминаю самому себе о вебинаре', 'urban.teacher@mail.ru', sender='urban.teacher@mail.ru')
Вывод на консоль:
Письмо успешно отправлено с адреса university.help@gmail.com на адрес vasyok1337@gmail.com
НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса urban.info@gmail.com на адрес urban.fan@mail.ru
Невозможно отправить письмо с адреса urban.teacher@mail.uk на адрес urban.student@mail.ru
Нельзя отправить письмо самому себе!

Примечания:
1.	Обязательно именованные аргументы отделяются от остальных символом "*" перед ними.
2.	Именованные аргументы всегда идут после позиционных.

3.3 Распаковка позиционных параметров".

Цель задания: Освоить создание функций с параметрами по умолчанию и практику вызова этих функций с различным количеством аргументов.

Задача "Распаковка":
1.Функция с параметрами по умолчанию:
1.	Создайте функцию print_params(a = 1, b = 'строка', c = True), которая принимает три параметра со значениями по умолчанию (например сейчас это: 1, 'строка', True).
2.	Функция должна выводить эти параметры.
3.	Вызовите функцию print_params с разным количеством аргументов, включая вызов без аргументов.
4.	Проверьте, работают ли вызовы print_params(b = 25) print_params(c = [1,2,3])
2.Распаковка параметров:
1.	Создайте список values_list с тремя элементами разных типов.
2.	Создайте словарь values_dict с тремя ключами, соответствующими параметрам функции print_params, и значениями разных типов.
3.	Передайте values_list и values_dict в функцию print_params, используя распаковку параметров (* для списка и ** для словаря).
3.Распаковка + отдельные параметры:
1.	Создайте список values_list_2 с двумя элементами разных типов
2.	Проверьте, работает ли print_params(*values_list_2, 42)
Пример результата выполнения программы:
Исходный код:
values_list_2 = [54.32, 'Строка' ]
print_params(*values_list_2, 42)
Вывод на консоль:
54.32 'Строка' 42

Примечания:
1.	Использование параметров по умолчанию позволяет функциям быть гибкими и удобными в использовании.
2.	Распаковка параметров из списка и словаря позволяет передавать группы значений в функцию, что упрощает работу с данными.
Важно!
Не передавайте списки задавая по умолчанию пустой список или другой изменяемый тип данных!
В таком случае, если этот список будет изменён внутри функции, то на следующий вызов функции он останется в том же состоянии.
def a(my_list = [])) – это приводит к ошибкам!

Можно передавать вот так(список создаётся локально, мы не влияем на его изменение вне функции)
def append_to_list(item, list_my=None):
  if list_my is None:
   list_my = []
  list_my.append(item)
print(list_my)


3.4 *args/ **kwargs на практике.

Задача "Однокоренные":
Напишите функцию single_root_words, которая принимает одно обязательное слово в параметр root_word, а далее неограниченную последовательность в параметр *other_words.
Функция должна составить новый список same_words только из тех слов списка other_words, которые содержат root_word или наоборот root_word содержит одно из этих слов. После вернуть список same_words в качестве результата своей работы.

Пункты задачи:
1.	Объявите функцию single_root_words и напишите в ней параметры root_word и *other_words.
2.	Создайте внутри функции пустой список same_words, который пополнится нужными словами.
3.	При помощи цикла for переберите предполагаемо подходящие слова.
4.	Пропишите корректное относительно задачи условие, при котором добавляются слова в результирующий список same_words.
5.	После цикла верните образованный функцией список same_words.
6.	Вызовите функцию single_root_words и выведете на экран(консоль) возвращённое ей значение.
Пример результата выполнения программы:
Исходный код:
result1 = single_root_words('rich', 'richiest', 'orichalcum', 'cheers', 'richies')
result2 = single_root_words('Disablement', 'Able', 'Mable', 'Disable', 'Bagel')
print(result1)
print(result2)
Вывод на консоль:
['richiest', 'orichalcum', 'richies']
['Able', 'Disable']
Примечания:
1.	При проверке наличия одного слова в составе другого стоит учесть, что регистр символов не должен влиять ни на что. ('Disablement' - 'Able') ('Able', 'able', 'AbLe' - все подходят)
2.	В этой задаче вам могут понадобиться следующие методы строк/ключевые слова:
а. Оператор in или count()
b. lower()/upper().


3.5 Рекурсия
Цель: применить знания о рекурсии в решении задачи.

Задача "Рекурсивное умножение цифр":
Напиши функцию get_multiplied_digits, которая принимает аргумент целое число number и подсчитывает произведение цифр этого числа.

Пункты задачи:
1.	Напишите функцию get_multiplied_digits и параметр number в ней.
2.	Создайте переменную str_number и запишите строковое представление(str) числа number в неё.
3.	Основной задачей будет отделение первой цифры в числе: создайте переменную first и запишите в неё первый символ из str_number в числовом представлении(int).
4.	Возвращайте значение first * get_multiplied_digits(int(str_number[1:])). Таким образом вы умножите первую цифру числа на результат работы этой же функции с числом, но уже без первой цифры.
5.	4 пункт можно выполнить только тогда, когда длина str_number больше 1, т.к. в противном случае не получиться взять срез str_number[1:].
6.	Если же длина str_number не больше 1, тогда вернуть оставшуюся цифру first.
Стек вызовов будет выглядеть следующим образом:
get_multiplied_digits(40203) -> 4 * get_multiplied_digits(203) -> 4 * 2 * get_multiplied_digits(3) -> 4 * 2 * 3

Пример результата выполнения программы:
Исходный код:
result = get_multiplied_digits(40203)
print(result)
result2 = get_multiplied_digits(402030)
print(result2)
Вывод на консоль:
24
24

Примечания:
1.	При преобразовании строки(str) в число(int) первые нули убираются. int('00123') -> 123.
2.	Если возникает ошибка, рекомендуется пошагово отладить программу "жучком". Чаще всего ошибка заключается в бесконечной рекурсии или же в неверном обращении по индексу.

 
Доп задание

Задание "Раз, два, три, четыре, пять .... Это не всё?":
Наши студенты, без исключения, - очень умные ребята. Настолько умные, что иногда по утру сами путаются в том, что намудрили вчера вечером.
Один из таких учеников уснул на клавиатуре в процессе упорной учёбы (ещё и трудолюбивые). Тем не менее, даже после сна, его код остался рабочим и выглядел следующим образом:

data_structure = [
  [1, 2, 3],
  {'a': 4, 'b': 5},
  (6, {'cube': 7, 'drum': 8}),
  "Hello",
  ((), [{(2, 'Urban', ('Urban2', 35))}])
]

Увидев это студент задался вопросом: "А есть ли универсальное решение для подсчёта суммы всех чисел и длин всех строк?"
Да, выглядит страшно, да и обращаться нужно к каждой внутренней структуре (списку, словарю и т.д.) по-разному.

Ученику пришлось каждый раз использовать индексацию и обращение по ключам - универсального решения для таких структур он не нашёл.

Помогите сокурснику осуществить его задумку.

Что должно быть подсчитано:
1.	Все числа (не важно, являются они ключами или значениям или ещё чем-то).
2.	Все строки (не важно, являются они ключами или значениям или ещё чем-то)

Для примера, указанного выше, расчёт вёлся следующим образом:
1 + 2 + 3 + len('a') + 4 + len('b') + 5 + 6 + len('cube') + 7 + .... + 35 = 99

Входные данные (применение функции):
data_structure = [
[1, 2, 3],
{'a': 4, 'b': 5},
(6, {'cube': 7, 'drum': 8}),
"Hello",
((), [{(2, 'Urban', ('Urban2', 35))}])
]

result = calculate_structure_sum(data_structure)
print(result)


Выходные данные (консоль):
99


Примечания (рекомендации):
1.	Весь подсчёт должен выполняться одним вызовом функции.
2.	Рекомендуется применить рекурсивный вызов функции, для каждой внутренней структуры.
3.	Т.к. каждая структура может содержать в себе ещё несколько элементов, можно использовать параметр *args
4.	Для определения типа данного используйте функцию isinstance.


